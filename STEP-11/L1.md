## 1. Intro to Heap and Complete Binary Tree (CBT)
 - Min and Max heap
 - Heap class implementation
 - Insertion in heap

![Heap 1-02](https://github.com/Mehul237/A2Z-DSA-Course/assets/117193057/352f38d0-dbdd-4b43-ba41-bcc73ef3fee2)
![Heap 1-03](https://github.com/Mehul237/A2Z-DSA-Course/assets/117193057/6d07f88e-d4d1-4903-bb05-34a22505c086)
![Heap 1-04](https://github.com/Mehul237/A2Z-DSA-Course/assets/117193057/49a81149-9516-43b7-8feb-861c5c167cf9)
![Heap 1-05](https://github.com/Mehul237/A2Z-DSA-Course/assets/117193057/191434b3-8207-45db-a131-8e7fdd75a11b)


```cpp

#include <bits/stdc++.h>
using namespace std;


class heap {

    public:
    int arr[100];
    int size;

    heap() {
        arr[0] = -1;
        size = 0;
    }

    // 1. Insert function
    void insert(int val) {

        // Step-01: insert at the end of the arr
        size = size + 1;
        int index = size;
        arr[index] = val;
        
        // Step-02: Find the parent index and compare the parent node to arr index
        //          -- If the parent node is smaller then the index of array then swap
        //          -- Update index to parent (index = parent)
        while(index > 1) {

            // 1. Parent find
            int parent = index / 2;

            // 2. Compare and swap
            if(arr[parent] < arr[index]) {
                swap(arr[parent], arr[index]);
                index = parent;
            } else {
                return;
            }
        }
    }

    
    // 2. Print function
    void print() {

        for(int i=1; i<=size; i++) {
            cout << arr[i] << " ";
        } 
        cout << "\n";
    }

};


int main() {

    heap h; // Max heap
    
    // Already correct position
    h.insert(60);
    h.insert(50);
    h.insert(40);
    h.insert(30);
    h.insert(20);

    // 1. Insert at end
    // 2. Take it to its correct position
    //   -- Compare (arr[parent] < arr[index]) and swap
    h.insert(55);
    h.insert(69);

    h.print();

    return 0;
}

```
